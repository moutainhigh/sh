// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.14/esri/copyright.txt for details.
//>>built
define("require exports ../../../../core/tsSupport/makeTemplateObjectHelper ../collections/Component/Material/shader/DecodeSymbolColor.glsl ../core/shaderLibrary/DiscardOrAdjustAlpha.glsl ../core/shaderLibrary/ForwardLinearDepth.glsl ../core/shaderLibrary/Offset.glsl ../core/shaderLibrary/Slice.glsl ../core/shaderLibrary/Transform.glsl ../core/shaderLibrary/attributes/PositionAttribute.glsl ../core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl ../core/shaderLibrary/attributes/VertexColor.glsl ../core/shaderLibrary/attributes/VertexNormal.glsl ../core/shaderLibrary/attributes/VerticalOffset.glsl ../core/shaderLibrary/output/OutputDepth.glsl ../core/shaderLibrary/shading/ComputeNormalTexture.glsl ../core/shaderLibrary/shading/EvaluateAmbientOcclusion.glsl ../core/shaderLibrary/shading/EvaluateSceneLighting.glsl ../core/shaderLibrary/shading/HighlightData.glsl ../core/shaderLibrary/shading/Normals.glsl ../core/shaderLibrary/shading/PhysicallyBasedRendering.glsl ../core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl ../core/shaderLibrary/shading/ReadShadowMap.glsl ../core/shaderLibrary/shading/VisualVariables.glsl ../core/shaderLibrary/util/DoublePrecision.glsl ../core/shaderLibrary/util/MixExternalColor.glsl ../core/shaderModules/interfaces ../core/shaderModules/ShaderBuilder".split(" "),
function(Sa,n,c,Aa,g,Ba,Ca,h,k,Da,l,Ea,p,Fa,Ga,Ha,Ia,Ja,Ka,La,Ma,Na,Oa,m,Pa,Qa,d,Ra){Object.defineProperty(n,"__esModule",{value:!0});n.build=function(a){var b=new Ra.ShaderBuilder,f=b.vertex.code,e=b.fragment.code;f.add(d.glsl(q||(q=c(["\n    // --- Default Material:\n    // ","\n    // ---\n  "],["\n    // --- Default Material:\n    // ","\n    // ---\n  "])),JSON.stringify(a)));e.add(d.glsl(r||(r=c(["\n    // --- Default Material:\n    // ","\n    // ---\n  "],["\n    // --- Default Material:\n    // ",
"\n    // ---\n  "])),JSON.stringify(a)));b.vertex.uniforms.add("proj","mat4").add("view","mat4").add("camPos","vec3").add("localOrigin","vec3");b.include(Da.PositionAttribute);b.varyings.add("vpos","vec3");b.include(m.VisualVariables,a);a.instanced&&a.instancedDoublePrecision?(b.attributes.add("modelOriginHi","vec3"),b.attributes.add("modelOriginLo","vec3"),b.attributes.add("model","mat3"),b.attributes.add("modelNormal","mat3")):(b.vertex.uniforms.add("model","mat4"),b.vertex.uniforms.add("modelNormal",
"mat4"));a.instancedDoublePrecision?(b.include(Pa.DoublePrecision,a),b.vertex.uniforms.add("viewOriginHi","vec3"),b.vertex.uniforms.add("viewOriginLo","vec3"),f.add(d.glsl(t||(t=c(["\n    vec3 calculateVPos() {\n      return model * localPosition().xyz;\n    }\n    "],["\n    vec3 calculateVPos() {\n      return model * localPosition().xyz;\n    }\n    "]))))):f.add(d.glsl(u||(u=c(["\n    vec3 calculateVPos() {\n      return (model * localPosition()).xyz;\n    }\n    "],["\n    vec3 calculateVPos() {\n      return (model * localPosition()).xyz;\n    }\n    "]))));
b.include(Fa.VerticalOffset,a);0===a.output&&(b.include(k.Transform,{linearDepth:!1}),0===a.normalType&&a.offsetBackfaces&&b.include(Ca.Offset),b.include(Ha.ComputeNormalTexture,a),b.include(p.VertexNormal,a),a.instancedColor&&b.attributes.add("instanceColor","vec4"),b.varyings.add("localvpos","vec3"),b.include(l.TextureCoordinateAttribute,a),b.include(Ba.ForwardLinearDepth,a),a.symbolColor?(b.include(Aa.DecodeSymbolColor),b.attributes.add("symbolColor","vec4"),b.varyings.add("colorMixMode","mediump float")):
b.fragment.uniforms.add("colorMixMode","int"),b.include(Ea.VertexColor,a),b.vertex.uniforms.add("externalColor","vec4"),b.varyings.add("vcolorExt","vec4"),b.vertex.defines.addFloat("SYMBOL_ALPHA_CUTOFF",.001),f.add(d.glsl(v||(v=c(["\n      void main(void) {\n        forwardNormalizedVertexColor();\n        vcolorExt \x3d externalColor;\n        ","\n        vcolorExt *\x3d vvColor();\n    "],["\n      void main(void) {\n        forwardNormalizedVertexColor();\n        vcolorExt \x3d externalColor;\n        ",
"\n        vcolorExt *\x3d vvColor();\n    "])),a.instancedColor?"vcolorExt *\x3d instanceColor;":"")),a.symbolColor&&f.add(d.glsl(w||(w=c(["\n        int symbolColorMixMode;\n        vcolorExt *\x3d decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451; // \x3d 1/255;\n        colorMixMode \x3d float(symbolColorMixMode) + 0.5; // add 0.5 to avoid interpolation artifacts\n      "],["\n        int symbolColorMixMode;\n        vcolorExt *\x3d decodeSymbolColor(symbolColor, symbolColorMixMode) * 0.003921568627451; // \x3d 1/255;\n        colorMixMode \x3d float(symbolColorMixMode) + 0.5; // add 0.5 to avoid interpolation artifacts\n      "])))),
f.add(d.glsl(x||(x=c(["\n        if (vcolorExt.a \x3c SYMBOL_ALPHA_CUTOFF) {\n          gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0);\n        }\n        else {\n          vpos \x3d calculateVPos();\n          localvpos \x3d vpos - view[3].xyz;\n    "],["\n        if (vcolorExt.a \x3c SYMBOL_ALPHA_CUTOFF) {\n          gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0);\n        }\n        else {\n          vpos \x3d calculateVPos();\n          localvpos \x3d vpos - view[3].xyz;\n    "])))),a.instancedDoublePrecision?
(0===a.normalType&&f.add(d.glsl(y||(y=c(["\n          vNormalWorld \x3d normalize(modelNormal * vvLocalNormal(normalModel()).xyz);\n        "],["\n          vNormalWorld \x3d normalize(modelNormal * vvLocalNormal(normalModel()).xyz);\n        "])))),f.add(d.glsl(z||(z=c(["\n          vec3 originDelta \x3d dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n          vpos -\x3d originDelta;\n      "],["\n          vec3 originDelta \x3d dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n          vpos -\x3d originDelta;\n      "]))))):
0===a.normalType&&f.add(d.glsl(A||(A=c(["\n          vNormalWorld \x3d normalize((modelNormal * vvLocalNormal(normalModel())).xyz);\n        "],["\n          vNormalWorld \x3d normalize((modelNormal * vvLocalNormal(normalModel())).xyz);\n        "])))),f.add(d.glsl(B||(B=c(["\n          ","\n          ","\n          gl_Position \x3d transformPosition(proj, view, vpos);\n          ","\n        }\n        forwardLinearDepth();\n        forwardTextureCoordinates();\n      }\n    "],["\n          ","\n          ",
"\n          gl_Position \x3d transformPosition(proj, view, vpos);\n          ","\n        }\n        forwardLinearDepth();\n        forwardTextureCoordinates();\n      }\n    "])),a.verticalOffsetEnabled?"vpos +\x3d calculateVerticalOffset(vpos, localOrigin);":"",a.vertexTangets?"transformVertexTangent(mat3(modelNormal));":"",0===a.normalType&&a.offsetBackfaces?"gl_Position \x3d offsetBackfacingClipPosition(gl_Position, vpos, vNormalWorld, camPos);":"")),b.include(h.Slice,a),b.include(Ja.EvaluateSceneLighting,
a),b.include(Ia.EvaluateAmbientOcclusion,a),b.include(g.DiscardOrAdjustAlpha,a),a.receiveShadows&&b.include(Oa.ReadShadowMap,a),b.fragment.uniforms.add("camPos","vec3").add("localOrigin","vec3").add("ambient","vec3").add("diffuse","vec3").add("specular","vec3").add("opacity","float").add("layerOpacity","float"),a.treeRendering&&b.fragment.uniforms.add("view","mat4"),a.hasColorTexture&&b.fragment.uniforms.add("tex","sampler2D"),3===a.normalType&&b.extensions.add("GL_OES_standard_derivatives"),b.include(Na.PhysicallyBasedRenderingParameters,
a),b.include(Ma.PhysicallyBasedRendering,a),b.include(Qa.MixExternalColor,{stages:1}),b.include(La.Normals,a),e.add(d.glsl(C||(C=c(["\n        void main() {\n          discardBySlice(vpos);\n    "],["\n        void main() {\n          discardBySlice(vpos);\n    "])))),a.hasColorTexture?(e.add(d.glsl(D||(D=c(["\n          vec4 texColor \x3d texture2D(tex, vuv0);\n      "],["\n          vec4 texColor \x3d texture2D(tex, vuv0);\n      "])))),a.textureAlphaPremultiplied&&e.add(d.glsl(E||(E=c(["\n            texColor.rgb /\x3d texColor.a;\n        "],
["\n            texColor.rgb /\x3d texColor.a;\n        "])))),e.add(d.glsl(F||(F=c(["\n            discardOrAdjustAlpha(texColor);\n      "],["\n            discardOrAdjustAlpha(texColor);\n      "]))))):e.add(d.glsl(G||(G=c(["\n            vec4 texColor \x3d vec4(1.0);\n      "],["\n            vec4 texColor \x3d vec4(1.0);\n      "])))),e.add(d.glsl(H||(H=c(["\n            shadingParams.viewDirection \x3d normalize(vpos - camPos);\n    "],["\n            shadingParams.viewDirection \x3d normalize(vpos - camPos);\n    "])))),
3===a.normalType?e.add(d.glsl(I||(I=c(["\n        vec3 normal \x3d normalize(cross(dFdx(localvpos),dFdy(localvpos)));\n      "],["\n        vec3 normal \x3d normalize(cross(dFdx(localvpos),dFdy(localvpos)));\n      "])))):e.add(d.glsl(J||(J=c(["\n        shadingParams.normalView \x3d vNormalWorld;\n        vec3 normal \x3d shadingNormal(shadingParams);\n      "],["\n        shadingParams.normalView \x3d vNormalWorld;\n        vec3 normal \x3d shadingNormal(shadingParams);\n      "])))),a.usePBR&&
e.add(d.glsl(K||(K=c(["applyPBRFactors();"],["applyPBRFactors();"])))),e.add(d.glsl(L||(L=c(["\n        float ssao \x3d evaluateAmbientOcclusionInverse();\n        ssao *\x3d getBakedOcclusion();\n\n        float additionalAmbientScale \x3d _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight \x3d ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n    "],["\n        float ssao \x3d evaluateAmbientOcclusionInverse();\n        ssao *\x3d getBakedOcclusion();\n\n        float additionalAmbientScale \x3d _oldHeuristicLighting(vpos + localOrigin);\n        vec3 additionalLight \x3d ssao * lightingMainIntensity * additionalAmbientScale * ambientBoostFactor * lightingGlobalFactor;\n    "])))),
a.receiveShadows?b.fragment.code.add(d.glsl(M||(M=c(["\n        float shadow \x3d readShadowMap(vpos, linearDepth);\n      "],["\n        float shadow \x3d readShadowMap(vpos, linearDepth);\n      "])))):0===a.viewingMode?b.fragment.code.add(d.glsl(N||(N=c(["\n        float shadow \x3d lightingGlobalFactor * (1.0 - additionalAmbientScale);\n      "],["\n        float shadow \x3d lightingGlobalFactor * (1.0 - additionalAmbientScale);\n      "])))):b.fragment.code.add(d.glsl(O||(O=c(["\n        float shadow \x3d 0.0;\n      "],
["\n        float shadow \x3d 0.0;\n      "])))),e.add(d.glsl(P||(P=c(["\n        vec3 matColor \x3d max(ambient, diffuse);\n    "],["\n        vec3 matColor \x3d max(ambient, diffuse);\n    "])))),a.attributeColor?e.add(d.glsl(Q||(Q=c(["\n        vec3 albedo_ \x3d mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ \x3d layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n      "],["\n        vec3 albedo_ \x3d mixExternalColor(vColor.rgb * matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ \x3d layerOpacity * mixExternalOpacity(vColor.a * opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n      "])))):
(e.add(d.glsl(R||(R=c(["\n        vec3 albedo_ \x3d mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ \x3d layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n      "],["\n        vec3 albedo_ \x3d mixExternalColor(matColor, texColor.rgb, vcolorExt.rgb, int(colorMixMode));\n        float opacity_ \x3d layerOpacity * mixExternalOpacity(opacity, texColor.a, vcolorExt.a, int(colorMixMode));\n      "])))),a.usePBR&&
e.add(d.glsl(S||(S=c(["\n          if (int(colorMixMode) \x3d\x3d 3 /* replace */) {\n            reflectance \x3d 0.2;\n            roughness \x3d 0.6;\n            metalness \x3d 0.0;\n          }\n        "],["\n          if (int(colorMixMode) \x3d\x3d 3 /* replace */) {\n            reflectance \x3d 0.2;\n            roughness \x3d 0.6;\n            metalness \x3d 0.0;\n          }\n        "]))))),a.hasNormalTexture?(a.vertexTangets?e.add(d.glsl(T||(T=c(["\n        mat3 tangentSpace \x3d computeTangentSpace(normal);\n        "],
["\n        mat3 tangentSpace \x3d computeTangentSpace(normal);\n        "])))):e.add(d.glsl(U||(U=c(["\n        mat3 tangentSpace \x3d computeTangentSpace(normal, vpos, vuv0);\n        "],["\n        mat3 tangentSpace \x3d computeTangentSpace(normal, vpos, vuv0);\n        "])))),e.add(d.glsl(V||(V=c(["\n        vec3 shadedNormal \x3d computeTextureNormal(tangentSpace, vuv0);\n      "],["\n        vec3 shadedNormal \x3d computeTextureNormal(tangentSpace, vuv0);\n      "]))))):e.add(d.glsl(W||(W=c(["\n        vec3 shadedNormal \x3d normal;\n      "],
["\n        vec3 shadedNormal \x3d normal;\n      "])))),a.treeRendering&&e.add(d.glsl(X||(X=c(["\n        shadedNormal \x3d normalize(vNormalWorld);\n        albedo_ *\x3d 1.2;\n        vec3 viewForward \x3d - vec3(view[0][2], view[1][2], view[2][2]);\n        float alignmentLightView \x3d clamp(dot(-viewForward, lightingMainDirection), 0.0, 1.0);\n\n        float transmittance \x3d 1.0 - clamp(dot(-viewForward, shadedNormal), 0.0, 1.0);\n        float treeRadialFalloff \x3d vColor.r;\n        float backLightFactor \x3d 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);\n        additionalLight +\x3d backLightFactor * lightingMainIntensity;\n    "],
["\n        shadedNormal \x3d normalize(vNormalWorld);\n        albedo_ *\x3d 1.2;\n        vec3 viewForward \x3d - vec3(view[0][2], view[1][2], view[2][2]);\n        float alignmentLightView \x3d clamp(dot(-viewForward, lightingMainDirection), 0.0, 1.0);\n\n        float transmittance \x3d 1.0 - clamp(dot(-viewForward, shadedNormal), 0.0, 1.0);\n        float treeRadialFalloff \x3d vColor.r;\n        float backLightFactor \x3d 0.5 * treeRadialFalloff * alignmentLightView * transmittance * (1.0 - shadow);\n        additionalLight +\x3d backLightFactor * lightingMainIntensity;\n    "])))),
a.usePBR?e.add(d.glsl(Y||(Y=c(["\n        float additionalAmbientIrradiance \x3d additionalAmbientIrradianceFactor * lightingMainIntensity[2];\n        vec3 normalGround \x3d normalize(vpos + localOrigin);\n        vec3 shadedColor \x3d evaluateSceneLightingPBR(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, roughness, metalness, emission, reflectance, additionalAmbientIrradiance);\n      "],["\n        float additionalAmbientIrradiance \x3d additionalAmbientIrradianceFactor * lightingMainIntensity[2];\n        vec3 normalGround \x3d normalize(vpos + localOrigin);\n        vec3 shadedColor \x3d evaluateSceneLightingPBR(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight, shadingParams.viewDirection, normalGround, roughness, metalness, emission, reflectance, additionalAmbientIrradiance);\n      "])))):
e.add(d.glsl(Z||(Z=c(["\n        vec3 shadedColor \x3d evaluateSceneLighting(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight);\n      "],["\n        vec3 shadedColor \x3d evaluateSceneLighting(shadedNormal, albedo_, shadow, 1.0 - ssao, additionalLight);\n      "])))),e.add(d.glsl(aa||(aa=c(["\n        gl_FragColor \x3d highlightSlice(vec4(shadedColor, opacity_), vpos);\n      }\n    "],["\n        gl_FragColor \x3d highlightSlice(vec4(shadedColor, opacity_), vpos);\n      }\n    "])))));
if(1===a.output||3===a.output)b.include(k.Transform,{linearDepth:!0}),b.include(l.TextureCoordinateAttribute,a),b.include(m.VisualVariables,a),b.include(Ga.OutputDepth,a),b.include(h.Slice,a),b.vertex.uniforms.add("nearFar","vec2"),b.varyings.add("depth","float"),a.hasColorTexture&&b.fragment.uniforms.add("tex","sampler2D"),f.add(d.glsl(ba||(ba=c(["\n      void main(void) {\n        vpos \x3d calculateVPos();\n    "],["\n      void main(void) {\n        vpos \x3d calculateVPos();\n    "])))),a.instancedDoublePrecision&&
f.add(d.glsl(ca||(ca=c(["\n        vec3 originDelta \x3d dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -\x3d originDelta;\n      "],["\n        vec3 originDelta \x3d dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -\x3d originDelta;\n      "])))),a.verticalOffsetEnabled&&f.add(d.glsl(da||(da=c(["\n        vpos +\x3d calculateVerticalOffset(vpos, localOrigin);\n      "],["\n        vpos +\x3d calculateVerticalOffset(vpos, localOrigin);\n      "])))),
f.add(d.glsl(ea||(ea=c(["\n        gl_Position \x3d transformPositionWithDepth(proj, view, vpos, nearFar, depth);\n        forwardTextureCoordinates();\n      }\n    "],["\n        gl_Position \x3d transformPositionWithDepth(proj, view, vpos, nearFar, depth);\n        forwardTextureCoordinates();\n      }\n    "])))),b.include(g.DiscardOrAdjustAlpha,a),e.add(d.glsl(fa||(fa=c(["\n      void main(void) {\n        discardBySlice(vpos);\n    "],["\n      void main(void) {\n        discardBySlice(vpos);\n    "])))),
a.hasColorTexture&&e.add(d.glsl(ga||(ga=c(["\n        vec4 texColor \x3d texture2D(tex, vuv0);\n        discardOrAdjustAlpha(texColor);\n      "],["\n        vec4 texColor \x3d texture2D(tex, vuv0);\n        discardOrAdjustAlpha(texColor);\n      "])))),e.add(d.glsl(ha||(ha=c(["\n        outputDepth(depth);\n      }\n    "],["\n        outputDepth(depth);\n      }\n    "]))));2===a.output&&(3===a.normalType&&b.extensions.add("GL_OES_standard_derivatives"),b.include(k.Transform,{linearDepth:!1}),b.include(p.VertexNormal,
a),b.include(l.TextureCoordinateAttribute,a),b.include(m.VisualVariables,a),a.hasColorTexture&&b.fragment.uniforms.add("tex","sampler2D"),b.vertex.uniforms.add("viewNormal","mat4"),b.varyings.add("vPositionView","vec3"),f.add(d.glsl(ia||(ia=c(["\n      void main(void) {\n        vpos \x3d calculateVPos();\n    "],["\n      void main(void) {\n        vpos \x3d calculateVPos();\n    "])))),a.instancedDoublePrecision?(0===a.normalType&&f.add(d.glsl(ja||(ja=c(["\n        vNormalWorld \x3d normalize((viewNormal * vec4(modelNormal * vvLocalNormal(normalModel()).xyz, 1.0)).xyz);\n        "],
["\n        vNormalWorld \x3d normalize((viewNormal * vec4(modelNormal * vvLocalNormal(normalModel()).xyz, 1.0)).xyz);\n        "])))),f.add(d.glsl(ka||(ka=c(["\n        vec3 originDelta \x3d dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -\x3d originDelta;\n      "],["\n        vec3 originDelta \x3d dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -\x3d originDelta;\n      "]))))):0===a.normalType&&f.add(d.glsl(la||(la=c(["\n        vNormalWorld \x3d normalize((viewNormal * modelNormal * vvLocalNormal(normalModel())).xyz);\n        "],
["\n        vNormalWorld \x3d normalize((viewNormal * modelNormal * vvLocalNormal(normalModel())).xyz);\n        "])))),a.verticalOffsetEnabled&&f.add(d.glsl(ma||(ma=c(["\n        vpos +\x3d calculateVerticalOffset(vpos, localOrigin);\n      "],["\n        vpos +\x3d calculateVerticalOffset(vpos, localOrigin);\n      "])))),f.add(d.glsl(na||(na=c(["\n        gl_Position \x3d transformPosition(proj, view, vpos);\n        forwardTextureCoordinates();\n      }\n    "],["\n        gl_Position \x3d transformPosition(proj, view, vpos);\n        forwardTextureCoordinates();\n      }\n    "])))),
b.include(h.Slice,a),b.include(g.DiscardOrAdjustAlpha,a),e.add(d.glsl(oa||(oa=c(["\n      void main() {\n        discardBySlice(vpos);\n    "],["\n      void main() {\n        discardBySlice(vpos);\n    "])))),a.hasColorTexture&&e.add(d.glsl(pa||(pa=c(["\n          vec4 texColor \x3d texture2D(tex, vuv0);\n          discardOrAdjustAlpha(texColor);\n      "],["\n          vec4 texColor \x3d texture2D(tex, vuv0);\n          discardOrAdjustAlpha(texColor);\n      "])))),3===a.normalType?e.add(d.glsl(qa||
(qa=c(["\n        vec3 normal \x3d normalize(cross(dFdx(vPositionView),dFdy(vPositionView)));\n      "],["\n        vec3 normal \x3d normalize(cross(dFdx(vPositionView),dFdy(vPositionView)));\n      "])))):e.add(d.glsl(ra||(ra=c(["\n        vec3 normal \x3d normalize(vNormalWorld);\n        if (gl_FrontFacing \x3d\x3d false) normal \x3d -normal;\n      "],["\n        vec3 normal \x3d normalize(vNormalWorld);\n        if (gl_FrontFacing \x3d\x3d false) normal \x3d -normal;\n      "])))),e.add(d.glsl(sa||
(sa=c(["\n        gl_FragColor \x3d vec4(vec3(0.5) + 0.5 * normal, 1.0);\n      }\n    "],["\n        gl_FragColor \x3d vec4(vec3(0.5) + 0.5 * normal, 1.0);\n      }\n    "])))));4===a.output&&(b.include(k.Transform,{linearDepth:!1}),b.include(l.TextureCoordinateAttribute,a),b.include(m.VisualVariables,a),a.hasColorTexture&&b.fragment.uniforms.add("tex","sampler2D"),f.add(d.glsl(ta||(ta=c(["\n      void main(void) {\n        vpos \x3d calculateVPos();\n    "],["\n      void main(void) {\n        vpos \x3d calculateVPos();\n    "])))),
a.instancedDoublePrecision&&f.add(d.glsl(ua||(ua=c(["\n        vec3 originDelta \x3d dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -\x3d originDelta;\n      "],["\n        vec3 originDelta \x3d dpAdd(viewOriginHi, viewOriginLo, -modelOriginHi, -modelOriginLo);\n        vpos -\x3d originDelta;\n      "])))),a.verticalOffsetEnabled&&f.add(d.glsl(va||(va=c(["\n        vpos +\x3d calculateVerticalOffset(vpos, localOrigin);\n      "],["\n        vpos +\x3d calculateVerticalOffset(vpos, localOrigin);\n      "])))),
f.add(d.glsl(wa||(wa=c(["\n        gl_Position \x3d transformPosition(proj, view, vpos);\n        forwardTextureCoordinates();\n      }\n    "],["\n        gl_Position \x3d transformPosition(proj, view, vpos);\n        forwardTextureCoordinates();\n      }\n    "])))),b.include(h.Slice,a),b.include(g.DiscardOrAdjustAlpha,a),b.include(Ka.HighlightData),b.fragment.uniforms.add("depthTex","sampler2D"),b.fragment.uniforms.add("highlightViewportPixelSz","vec4"),e.add(d.glsl(xa||(xa=c(["\n      void main() {\n        discardBySlice(vpos);\n    "],
["\n      void main() {\n        discardBySlice(vpos);\n    "])))),a.hasColorTexture&&e.add(d.glsl(ya||(ya=c(["\n        vec4 texColor \x3d texture2D(tex, vuv0);\n        discardOrAdjustAlpha(texColor);\n      "],["\n        vec4 texColor \x3d texture2D(tex, vuv0);\n        discardOrAdjustAlpha(texColor);\n      "])))),e.add(d.glsl(za||(za=c(["\n        gl_FragColor \x3d highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n      }\n    "],["\n        gl_FragColor \x3d highlightData(gl_FragCoord, depthTex, highlightViewportPixelSz);\n      }\n    "])))));
return b};var q,r,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,aa,ba,ca,da,ea,fa,ga,ha,ia,ja,ka,la,ma,na,oa,pa,qa,ra,sa,ta,ua,va,wa,xa,ya,za});