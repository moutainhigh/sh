// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.14/esri/copyright.txt for details.
//>>built
define(["require","exports","../../../../../../core/tsSupport/makeTemplateObjectHelper","../../shaderModules/interfaces"],function(m,f,b,c){Object.defineProperty(f,"__esModule",{value:!0});f.EvaluateAmbientLighting=function(a,d){a=a.fragment;var e=void 0!==d.lightingSphericalHarmonicsOrder?d.lightingSphericalHarmonicsOrder:2;0===e?(a.uniforms.add("lightingAmbientSH0","vec3"),a.code.add(c.glsl(g||(g=b(["\n      /**\n       * @param normal            shading normal in global coordinate space\n       * @param ambientOcclusion  amount of occlusion of the ambient light (1 \x3d\x3e full occlusion)\n       */\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec3 ambientLight \x3d 0.282095 * lightingAmbientSH0;\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "],
["\n      /**\n       * @param normal            shading normal in global coordinate space\n       * @param ambientOcclusion  amount of occlusion of the ambient light (1 \x3d\x3e full occlusion)\n       */\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec3 ambientLight \x3d 0.282095 * lightingAmbientSH0;\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "]))))):1===e?(a.uniforms.add("lightingAmbientSH_R","vec4"),a.uniforms.add("lightingAmbientSH_G",
"vec4"),a.uniforms.add("lightingAmbientSH_B","vec4"),a.code.add(c.glsl(h||(h=b(["\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec4 sh0 \x3d vec4(\n          0.282095,\n          0.488603 * normal.x,\n          0.488603 * normal.z,\n          0.488603 * normal.y\n        );\n        vec3 ambientLight \x3d vec3(\n          dot(lightingAmbientSH_R, sh0),\n          dot(lightingAmbientSH_G, sh0),\n          dot(lightingAmbientSH_B, sh0)\n        );\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "],
["\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec4 sh0 \x3d vec4(\n          0.282095,\n          0.488603 * normal.x,\n          0.488603 * normal.z,\n          0.488603 * normal.y\n        );\n        vec3 ambientLight \x3d vec3(\n          dot(lightingAmbientSH_R, sh0),\n          dot(lightingAmbientSH_G, sh0),\n          dot(lightingAmbientSH_B, sh0)\n        );\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "]))))):2===e&&(a.uniforms.add("lightingAmbientSH0",
"vec3"),a.uniforms.add("lightingAmbientSH_R1","vec4"),a.uniforms.add("lightingAmbientSH_G1","vec4"),a.uniforms.add("lightingAmbientSH_B1","vec4"),a.uniforms.add("lightingAmbientSH_R2","vec4"),a.uniforms.add("lightingAmbientSH_G2","vec4"),a.uniforms.add("lightingAmbientSH_B2","vec4"),a.code.add(c.glsl(k||(k=b(["\n      /**\n       * @param normal            shading normal in global coordinate space\n       * @param ambientOcclusion  amount of occlusion of the ambient light (1 \x3d\x3e full occlusion)\n       */\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec3 ambientLight \x3d 0.282095 * lightingAmbientSH0;\n\n        vec4 sh1 \x3d vec4(\n          0.488603 * normal.x,\n          0.488603 * normal.z,\n          0.488603 * normal.y,\n          1.092548 * normal.x * normal.y\n        );\n        vec4 sh2 \x3d vec4(\n          1.092548 * normal.y * normal.z,\n          0.315392 * (3.0 * normal.z * normal.z - 1.0),\n          1.092548 * normal.x * normal.z,\n          0.546274 * (normal.x * normal.x - normal.y * normal.y)\n        );\n        ambientLight +\x3d vec3(\n          dot(lightingAmbientSH_R1, sh1),\n          dot(lightingAmbientSH_G1, sh1),\n          dot(lightingAmbientSH_B1, sh1)\n        );\n        ambientLight +\x3d vec3(\n          dot(lightingAmbientSH_R2, sh2),\n          dot(lightingAmbientSH_G2, sh2),\n          dot(lightingAmbientSH_B2, sh2)\n        );\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "],
["\n      /**\n       * @param normal            shading normal in global coordinate space\n       * @param ambientOcclusion  amount of occlusion of the ambient light (1 \x3d\x3e full occlusion)\n       */\n      vec3 calculateAmbientIrradiance(vec3 normal, float ambientOcclusion) {\n        vec3 ambientLight \x3d 0.282095 * lightingAmbientSH0;\n\n        vec4 sh1 \x3d vec4(\n          0.488603 * normal.x,\n          0.488603 * normal.z,\n          0.488603 * normal.y,\n          1.092548 * normal.x * normal.y\n        );\n        vec4 sh2 \x3d vec4(\n          1.092548 * normal.y * normal.z,\n          0.315392 * (3.0 * normal.z * normal.z - 1.0),\n          1.092548 * normal.x * normal.z,\n          0.546274 * (normal.x * normal.x - normal.y * normal.y)\n        );\n        ambientLight +\x3d vec3(\n          dot(lightingAmbientSH_R1, sh1),\n          dot(lightingAmbientSH_G1, sh1),\n          dot(lightingAmbientSH_B1, sh1)\n        );\n        ambientLight +\x3d vec3(\n          dot(lightingAmbientSH_R2, sh2),\n          dot(lightingAmbientSH_G2, sh2),\n          dot(lightingAmbientSH_B2, sh2)\n        );\n        return ambientLight * (1.0 - ambientOcclusion);\n      }\n    "])))),
d.usePBR&&a.code.add(c.glsl(l||(l=b(["\n        // calculateAmbientRadiance is used calculate specular radiance of the sky\n        // - in the night calculateAmbientRadiance gives darker color compared to calculateAmbientComponent which integrates contributions of the moon\n        // - calculateAmbientRadiance gives more predictable color compared to calculateAmbientIrradiance that depends on normal\n        // - in future more physically accurate model should be established\n        vec3 calculateAmbientRadiance(float ssao)\n        {\n          // evaluate the sh ambient light\n          vec3 ambientLight ;\n          ambientLight \x3d 1.2 * (0.282095 * lightingAmbientSH0) - 0.2; // returning the darker value in the night\n\n          return ambientLight *\x3d (1.0 - ssao) * skyTransmittance; // skyTransmittance is slightly bluish giving more natural look\n        }\n      "],
["\n        // calculateAmbientRadiance is used calculate specular radiance of the sky\n        // - in the night calculateAmbientRadiance gives darker color compared to calculateAmbientComponent which integrates contributions of the moon\n        // - calculateAmbientRadiance gives more predictable color compared to calculateAmbientIrradiance that depends on normal\n        // - in future more physically accurate model should be established\n        vec3 calculateAmbientRadiance(float ssao)\n        {\n          // evaluate the sh ambient light\n          vec3 ambientLight ;\n          ambientLight \x3d 1.2 * (0.282095 * lightingAmbientSH0) - 0.2; // returning the darker value in the night\n\n          return ambientLight *\x3d (1.0 - ssao) * skyTransmittance; // skyTransmittance is slightly bluish giving more natural look\n        }\n      "])))))};
var g,h,k,l});