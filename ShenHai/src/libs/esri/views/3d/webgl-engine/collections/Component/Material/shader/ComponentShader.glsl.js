// All material copyright ESRI, All Rights Reserved, unless otherwise specified.
// See https://js.arcgis.com/4.14/esri/copyright.txt for details.
//>>built
define("require exports ../../../../../../../core/tsSupport/makeTemplateObjectHelper ./ComponentData.glsl ./VertexDiscardByOpacity.glsl ../../../../core/shaderLibrary/DiscardOrAdjustAlpha.glsl ../../../../core/shaderLibrary/ForwardLinearDepth.glsl ../../../../core/shaderLibrary/Slice.glsl ../../../../core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl ../../../../core/shaderLibrary/attributes/VertexColor.glsl ../../../../core/shaderLibrary/attributes/VertexNormal.glsl ../../../../core/shaderLibrary/attributes/VertexPosition.glsl ../../../../core/shaderLibrary/output/OutputDepth.glsl ../../../../core/shaderLibrary/output/OutputHighlight.glsl ../../../../core/shaderLibrary/shading/ComputeMaterialColor.glsl ../../../../core/shaderLibrary/shading/ComputeNormalTexture.glsl ../../../../core/shaderLibrary/shading/ComputeShadingNormal.glsl ../../../../core/shaderLibrary/shading/EvaluateSceneLighting.glsl ../../../../core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl ../../../../core/shaderLibrary/shading/ReadBaseColorTexture.glsl ../../../../core/shaderLibrary/shading/ReadShadowMap.glsl ../../../../core/shaderModules/interfaces ../../../../core/shaderModules/ShaderBuilder".split(" "),
function(V,e,c,D,E,F,G,H,I,J,K,L,M,N,O,P,f,Q,R,S,T,d,U){Object.defineProperty(e,"__esModule",{value:!0});e.attributeLocations={position:0,normal:1,normalCompressed:1,color:2,uv0:3,uvRegion:4,componentIndex:5};e.build=function(b){var a=new U.ShaderBuilder;a.include(L.VertexPosition,b);a.include(K.VertexNormal,b);a.include(J.VertexColor,b);a.include(I.TextureCoordinateAttribute,b);a.include(G.ForwardLinearDepth,b);a.include(D.ComponentData,b);a.include(F.DiscardOrAdjustAlpha,b);a.include(H.Slice,b);
a.include(S.ReadBaseColorTexture,b);a.include(E.VertexDiscardByOpacity,b);b.usePBR&&(a.include(R.PhysicallyBasedRenderingParameters,b),a.include(P.ComputeNormalTexture,b));3===b.output&&1===b.componentData?a.vertex.code.add(d.glsl(g||(g=c(["\n      #define discardShadows(castShadows) { if(!castShadows) { gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0); return; } }\n    "],["\n      #define discardShadows(castShadows) { if(!castShadows) { gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0); return; } }\n    "])))):
a.vertex.code.add(d.glsl(h||(h=c(["\n      #define discardShadows(castShadows) {}\n    "],["\n      #define discardShadows(castShadows) {}\n    "]))));a.vertex.code.add(d.glsl(k||(k=c(["\n    #define SYMBOL_ALPHA_CUTOFF 0.001\n\n    void main() {\n      bool castShadows;\n      vec4 externalColor \x3d forwardExternalColor(castShadows);\n      discardShadows(castShadows);\n\n      vertexDiscardByOpacity(externalColor.a);\n\n      if (externalColor.a \x3c SYMBOL_ALPHA_CUTOFF) {\n        // Discard this vertex\n        gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n\n      forwardPosition();\n      forwardNormal();\n      forwardTextureCoordinates();\n      forwardVertexColor();\n      forwardLinearDepth(); // depends on forwardPosition()\n    }\n  "],
["\n    #define SYMBOL_ALPHA_CUTOFF 0.001\n\n    void main() {\n      bool castShadows;\n      vec4 externalColor \x3d forwardExternalColor(castShadows);\n      discardShadows(castShadows);\n\n      vertexDiscardByOpacity(externalColor.a);\n\n      if (externalColor.a \x3c SYMBOL_ALPHA_CUTOFF) {\n        // Discard this vertex\n        gl_Position \x3d vec4(1e38, 1e38, 1e38, 1.0);\n        return;\n      }\n\n      forwardPosition();\n      forwardNormal();\n      forwardTextureCoordinates();\n      forwardVertexColor();\n      forwardLinearDepth(); // depends on forwardPosition()\n    }\n  "]))));
0===b.output&&(a.include(O.ComputeMaterialColor,b),a.include(f.ComputeShadingNormal,b),a.include(Q.EvaluateSceneLighting,b),b.receiveShadows?(a.include(T.ReadShadowMap,b),a.fragment.code.add(d.glsl(l||(l=c(["\n        float evaluateShadow() {\n          return readShadowMap(vPositionWorldCameraRelative, linearDepth);\n        }\n      "],["\n        float evaluateShadow() {\n          return readShadowMap(vPositionWorldCameraRelative, linearDepth);\n        }\n      "]))))):a.fragment.code.add(d.glsl(m||
(m=c(["\n        float evaluateShadow() { return 0.0; }\n      "],["\n        float evaluateShadow() { return 0.0; }\n      "])))),a.fragment.code.add(d.glsl(n||(n=c(["\n      // ShaderOutput.Color\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        vec4 externalColor;\n        int externalColorMixMode;\n        readExternalColor(externalColor, externalColorMixMode);\n\n        vec4 materialColor \x3d computeMaterialColor(\n          textureColor,\n          externalColor,\n          externalColorMixMode\n        );\n        "],
["\n      // ShaderOutput.Color\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        vec4 externalColor;\n        int externalColorMixMode;\n        readExternalColor(externalColor, externalColorMixMode);\n\n        vec4 materialColor \x3d computeMaterialColor(\n          textureColor,\n          externalColor,\n          externalColorMixMode\n        );\n        "])))),
b.usePBR?(a.fragment.code.add(d.glsl(p||(p=c(["\n        applyPBRFactors();\n        vec3 normalVertex \x3d shadingNormalWorld();\n        float additionalIrradiance \x3d 0.02 * lightingMainIntensity[2];;\n      "],["\n        applyPBRFactors();\n        vec3 normalVertex \x3d shadingNormalWorld();\n        float additionalIrradiance \x3d 0.02 * lightingMainIntensity[2];;\n      "])))),a.fragment.code.add(d.glsl(q||(q=c(["\n        if (int(externalColorMixMode) \x3d\x3d 3 /* replace */) {\n          reflectance \x3d 0.2;\n          roughness \x3d 0.6;\n          metalness \x3d 0.0;\n        }\n      "],
["\n        if (int(externalColorMixMode) \x3d\x3d 3 /* replace */) {\n          reflectance \x3d 0.2;\n          roughness \x3d 0.6;\n          metalness \x3d 0.0;\n        }\n      "])))),b.hasNormalTexture?a.fragment.code.add(d.glsl(r||(r=c(["\n        mat3 tangentSpace \x3d computeTangentSpace(normalVertex, vPositionWorldCameraRelative, vuv0);\n        vec3 shadingNormal \x3d computeTextureNormal(tangentSpace, vuv0);\n        "],["\n        mat3 tangentSpace \x3d computeTangentSpace(normalVertex, vPositionWorldCameraRelative, vuv0);\n        vec3 shadingNormal \x3d computeTextureNormal(tangentSpace, vuv0);\n        "])))):
a.fragment.code.add(d.glsl(t||(t=c(["\n        vec3 shadingNormal \x3d normalVertex;\n        "],["\n        vec3 shadingNormal \x3d normalVertex;\n        "])))),a.fragment.code.add(d.glsl(u||(u=c(["\n        vec3 normalGround \x3d normalize(positionWorld());\n        vec3 viewDir \x3d normalize(vPositionWorldCameraRelative);\n        float ssao \x3d 1.0 - occlusion * (1.0 - evaluateAmbientOcclusion());\n        vec3 additionalLight \x3d evaluateAdditionalLighting(ssao, positionWorld());\n        vec3 shadedColor \x3d evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, evaluateShadow(), ssao, additionalLight, viewDir, normalGround, roughness, metalness, emission, reflectance, additionalIrradiance);\n        "],
["\n        vec3 normalGround \x3d normalize(positionWorld());\n        vec3 viewDir \x3d normalize(vPositionWorldCameraRelative);\n        float ssao \x3d 1.0 - occlusion * (1.0 - evaluateAmbientOcclusion());\n        vec3 additionalLight \x3d evaluateAdditionalLighting(ssao, positionWorld());\n        vec3 shadedColor \x3d evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, evaluateShadow(), ssao, additionalLight, viewDir, normalGround, roughness, metalness, emission, reflectance, additionalIrradiance);\n        "]))))):
(b.receiveShadows?a.fragment.code.add(d.glsl(v||(v=c(["\n      float shadow \x3d evaluateShadow();\n        "],["\n      float shadow \x3d evaluateShadow();\n        "])))):0===b.viewingMode?a.fragment.code.add(d.glsl(w||(w=c(["\n      float additionalAmbientScale \x3d _oldHeuristicLighting(positionWorld());\n      float shadow \x3d lightingGlobalFactor * (1.0 - additionalAmbientScale);\n        "],["\n      float additionalAmbientScale \x3d _oldHeuristicLighting(positionWorld());\n      float shadow \x3d lightingGlobalFactor * (1.0 - additionalAmbientScale);\n        "])))):
a.fragment.code.add(d.glsl(x||(x=c(["\n      float shadow \x3d 0.0;\n      "],["\n      float shadow \x3d 0.0;\n      "])))),a.fragment.code.add(d.glsl(y||(y=c(["\n      float ambientOcclusion \x3d evaluateAmbientOcclusion();\n      // At global scale we create some additional ambient light based on the main light to simulate global illumination\n      vec3 additionalLight \x3d evaluateAdditionalLighting(ambientOcclusion, positionWorld());\n      vec3 shadedColor \x3d evaluateSceneLighting(shadingNormalWorld(), materialColor.rgb, shadow, ambientOcclusion, additionalLight);\n      "],
["\n      float ambientOcclusion \x3d evaluateAmbientOcclusion();\n      // At global scale we create some additional ambient light based on the main light to simulate global illumination\n      vec3 additionalLight \x3d evaluateAdditionalLighting(ambientOcclusion, positionWorld());\n      vec3 shadedColor \x3d evaluateSceneLighting(shadingNormalWorld(), materialColor.rgb, shadow, ambientOcclusion, additionalLight);\n      "]))))),a.fragment.code.add(d.glsl(z||(z=c(["\n        gl_FragColor \x3d highlightSlice(vec4(shadedColor, materialColor.a), vPositionWorldCameraRelative);\n      }\n    "],
["\n        gl_FragColor \x3d highlightSlice(vec4(shadedColor, materialColor.a), vPositionWorldCameraRelative);\n      }\n    "])))));if(1===b.output||3===b.output)a.include(M.OutputDepth,b),a.fragment.code.add(d.glsl(A||(A=c(["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        outputDepth(linearDepth);\n      }\n    "],["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        outputDepth(linearDepth);\n      }\n    "]))));
2===b.output&&(a.include(f.ComputeShadingNormal,b),a.fragment.code.add(d.glsl(B||(B=c(["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        // note: the alpha component needs to be 1.0 in order for this material\n        // to influence ambient occlusion, see the ssao fragment shader\n        gl_FragColor \x3d vec4(vec3(.5) + .5 * shadingNormal_view(), 1.0);\n      }\n    "],
["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        // note: the alpha component needs to be 1.0 in order for this material\n        // to influence ambient occlusion, see the ssao fragment shader\n        gl_FragColor \x3d vec4(vec3(.5) + .5 * shadingNormal_view(), 1.0);\n      }\n    "])))));4===b.output&&(a.include(N.OutputHighlight),a.fragment.code.add(d.glsl(C||
(C=c(["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        outputHighlight();\n      }\n    "],["\n      void main() {\n        discardBySlice(vPositionWorldCameraRelative);\n\n        vec4 textureColor \x3d readBaseColorTexture();\n        discardOrAdjustAlpha(textureColor);\n\n        outputHighlight();\n      }\n    "])))));return a};var g,h,k,l,m,n,p,q,r,t,
u,v,w,x,y,z,A,B,C});